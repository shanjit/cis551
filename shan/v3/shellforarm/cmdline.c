/*
 * utility functions used by the "io"
 * command to deal with command lines and
 * arguments.
 */

#include "io.h"
#include "var.h"

char 
	*emalloc(),
	*delete_arg();

void
	pre_command_assigns(),
	do_assigns(),
	do_command(),
	do_builtin(),
  	next_line();

int
	all_assigns(),
	builtin();

/*
 * do_line
 * takes a structure generated by a parsed command line,
 * and analyzes it. The result is (probably) a new process. 
 * I/O redirection and
 * command execution are then performed in the new process.
 */


int
do_line( line )
struct command_line *line;
{
	int pid, pfd[2];
		
	if( line->next == (struct command_line *) NULL )
	{
		do_command( line );
	}
	else
	{
		pipe( pfd );

		switch( (pid=fork()) )
		{
		case -1:	/* failure */
			return( -1 );
		
		case 0:
			close( pfd[0] );
			dup2( pfd[1], 1 );
			close( pfd[1] );
			do_line( line->next );

		default:
			close( pfd[1] );
			dup2( pfd[0], 0 );
			close( pfd[0] );
			do_command( line );
		}
	}
	return( pid );
		
}

int
cmdline( line )
struct command_line *line;
{
	extern int ErrFlag, BackGround, Status;
	int pid;

	if( ErrFlag == TRUE )
		return( -1 );

	if( all_assigns( line ) == TRUE )
	{
		do_assigns( line );
		next_line( line );
		return( 0 );		/* is this value ok? */
	}

	switch( (pid = fork()) )
	{
	case -1:
		return( -1 );

	case 0:
		pre_command_assigns( line );
		do_line( line );

	default:
		if( BackGround == TRUE )
		{
			printf( "%d\n", pid );
		}
		else
			wait( &Status );

	}

	next_line( line );
	return( pid );

}

void
do_command( line )
struct command_line *line;
{
	void do_io(), do_args();

	do_io( line->IoCmd );
	do_args( line );
	return;
}

void clear_io();

struct command_line *
make_pipe( old_line )
struct command_line *old_line;
{
	struct command_line *new, *line_alloc();

	new = line_alloc();
	clear_io( new );
	new->next = old_line;

	return( new );
}

/*
 * does an exec with the passed arguments
 * the name maybe should be found in the parent;
 * I'm not sure how the child would report
 * this failure back to the parent.
 */

void
do_args( line )
struct command_line *line;
{
	char *command, 
		*find_name(), 
		**build_list(),
		**list,
		**export(),
		**our_env;

	if( line->ArgList == (struct string_list *) NULL )
	  	exit( 0 );	/* must have had no commands? */

	list = build_list( line );

	if( builtin( list[0] ) == TRUE  )
	{
		do_builtin( list );
		exit( 0 );
	}

	/* need more error checking here */
  	command = find_name( list[0] );	/* name search in parent? */
	if( command == (char *) NULL )
	{
		fprintf( stderr, "%s: command not found\n", list[0] );
		exit( 1 );
	}

	our_env = export( (char **) NULL );

	execve( command, list, our_env );
	perror( command );
	exit( 1 );
}

/*
 * find_name()
 * - used to ape the shell's path name searching using PATH;
 * this value is not necessarily available to a sub-shell we
 * might otherwise execute.
 */

char *
find_name( name )
char *name;
{
	char 
		*cmd, 
		*path, 
		*prefix, 
		*make_cmd(), 
    		*getenv(), 
		*strsave(),
		*next_piece();

	/* deal with trivial special case, fully qualified path
	 * name.
	 */
	if( name[0] == '/' )
		return( name );	/* should we return a copy? */

	path = getenv( "PATH" );

	if( path == (char *) NULL )
		return( (char *) NULL );

	path = strsave( path );

	for( cmd = (char *) NULL, prefix = next_piece( path );
		prefix != (char *) NULL;
		prefix = next_piece( (char *) NULL ) )
	{ 
		cmd = make_cmd( prefix, name );
		if( is_x( cmd ) )
			break;
		free( cmd );
		cmd = (char *) NULL;
	}

	free( path );
	return( cmd ); 
}

/*
 * make_cmd()
 * builds a path name from the passed arguments.
 */

char * 
make_cmd( prefix, name )
char *prefix, *name; 
{
	char *p, *q;

	p = (char *) emalloc( strlen( prefix ) + strlen( name ) + 2 );
	
	q = p;
	while( *q = *prefix )
		++q, ++prefix;
	if( q != p )	/* special case, null component */
		*q++ = '/';
	while( *q = *name )
		++q, ++name;


	return( p ); 
}

/*
 * is_x:
 * somewhat machine-dependent routine which determines if the file named
 * by path_name is an executable file (a.out or shell procedure).
 * the function returns TRUE if it's executable, FALSE otherwise.
 */

is_x( path_name )
char *path_name; 
{
	struct stat sb;

#ifndef X_OK
# define X_OK (01)
#endif
	if( access( path_name, X_OK ) == -1 )
		return( FALSE );

	/* so far, so good. Also have to ensure that
	 * it's not a directory. Note that stat() should
	 * have no problem, as access() worked if we got here.
 	 * We'll check anyway for safety.
	 */
	if( stat( path_name, &sb ) < 0 )
		return( FALSE );


	if( ( sb.st_mode & S_IFMT ) == S_IFDIR ) /* directory */
		return( FALSE );

	return( TRUE );
}

/* same_name
 * returns TRUE if the two variables have the same
 * name, FALSE otherwise.
 */

int 
same_name( estr1, estr2 ) 
char *estr1, *estr2; 
{
	for( ;  *estr1 != '\0' && *estr1 == *estr2; ++estr1, ++estr2 )
		if( *estr1 == '=' )
			return( TRUE );

	return( FALSE ); 
}

/*
 * next_piece
 * - returns the next piece of the path pointed to by the "path"
 * argument passed the first time it is called. Subsequent calls
 * with path == (char *) NULL use the position remebered from the
 * previous call to parse through the string. This is a poor man's
 * strtok(3).
 */

char * 
next_piece( path ) 
char *path; 
{
	char *ret_val;
	register char *p;
	static char *start;

	if( path != (char *) NULL )
		start = path;

	for( p = start; *p != '\0' && *p != ':'; ++p )
		;

	if( *p == '\0' )
	{
	  	if( p == start )
			ret_val = (char *) NULL;
		else
		{
			ret_val = start;
			start = p;
		}
	}
	else
	{
		*p = '\0';
		ret_val = start;
		start = ++p;
	}

	return( ret_val );
}

/*
 * allocates necessary storage for a command line.
 * Note that the space is zeroed out.
 */

struct command_line *
line_alloc()
{
  	char *emalloc(), *line_space;
	register int i;
	int count = sizeof( struct command_line );
	
	line_space = emalloc( count );

	for( i = 0; i < count; i += 1 )
		line_space[i] = 0;

	return( (struct command_line *) line_space );

}

/*
 * properly initializes data structures for the next command line
 */

void
next_line( line )
struct command_line *line;
{
 	char *p;
	void safe_free();
	extern int ErrFlag, BackGround;

	/* clear any error flags */
	ErrFlag = FALSE;

	/* status flags */
	BackGround = FALSE;

	if( line == (struct command_line *) NULL )
		return;

	if( line->next != (struct command_line *) NULL )
	{
		next_line( line->next );
		safe_free( line->next );
		line->next = (struct command_line *) NULL;
	}
	
	/* Arguments */
	while( (p=delete_arg( line ) ) != (char *) NULL )
		safe_free( p );

	/* I/O commands */
	clear_io( line );


	return;
}

/*
 * do_word
 * do_word() does any file name generation that can be done on
 * "word" before it's inserted into the argument list associated
 * with "line".
 */

void
do_word( line, word )
struct command_line *line;
char *word;
{
	extern char **expand();
	char **expansions;
	void insert_arg();

	for( expansions = expand( word );
		*expansions != (char *) NULL;
		++expansions )
	{
		insert_arg( line, *expansions );
	}

	return;
}


/*
 * insert_arg puts a new string-valued argument (should a copy be made?)
 * into the argument list associated with a command. Since, to keep insertion
 * speed high, the list is kept in last-first order, the elements have to
 * be reversed to form a properly ordered argument list.
 */

void 
insert_arg( line, arg )
struct command_line *line;
char *arg;
{
	struct string_list *slp;

	/* inserting at the front of the list will ensure that this
	 * is the last argument.
	 */
	slp = (struct string_list *)
		emalloc( sizeof( struct string_list ) );

	slp->string = arg;		/* copy necessary here ? */
	slp->next = line->ArgList;
	line->ArgList = slp;

	return;
	
}

char *
delete_arg( line )
struct command_line *line;
{
	struct string_list *slp;
	char *p;

	slp = line->ArgList;

	if( slp == (struct string_list *) NULL )
		return( (char *) NULL );

	p = slp->string;
	slp = slp->next;
	free( line->ArgList );
	line->ArgList = slp;
	
	return( p );
}


long
count_args( list )
register struct string_list *list;
{
	long count;
	
	for( count = 0L; list != (struct string_list *) NULL;
		list = list->next )
		count += 1;

	return( count );
}

/*
 * builds a null-terminated list from the contents of a passed
 * struct string_list pointer.
 */

char **
build_list( line )
struct command_line *line;
{
	struct string_list *args;
	register count;
	char **list;
	
	count = (int) count_args( line->ArgList );

	list = (char **) emalloc( (count+1) * sizeof( char * ) );
	
	for( list[count] = (char *) NULL; count > 0; )
	{
	  	count -= 1;
		list[count] = delete_arg( line );
if( list[count] == (char *) NULL )
fprintf( stderr, "NULL pointer encountered in constructing list\n" );
	}

	return( list );
}


/* 
 * print_args()
 * utility function to print objects which are
 * constructed out of struct string_lists
 */
	
print_args( args )
struct string_list *args;
{
  	while( args != (struct string_list *) NULL )
	{
		fprintf( stderr, "%s\n", args->string );
		args = args->next;
	}
}
	

int
all_assigns( line )
struct command_line *line;
{
	struct string_list *args;
	extern int BackGround;

	if( BackGround == TRUE )
		return( FALSE );

	for( args = line->ArgList;
		args != (struct string_list *) NULL;
		args = args->next )
	{
		if( find_equals( args->string ) == (char *) NULL )
			return( FALSE );
	}

	return( TRUE );

}

extern void assign();

void
do_assigns( line )
struct command_line *line;
{
	struct string_list *args;

	for( args = line->ArgList;
		args != (struct string_list *) NULL;
		args = args->next )
	{
		assign( args->string, V_LOCAL );
	}

	return;
}


void
pre_command_assigns( line )
struct command_line *line;
{
	struct string_list *args;
	
	for( args = line->ArgList;
		args != (struct string_list *) NULL;
		args = args->next )
	{
		if( find_equals( args->string ) == (char *) NULL )
			break;
		assign( args->string, V_EXPORTED );
	}

	line->ArgList = args;

	return;
}


	
